================================================================================
OPTIMIZATION
================================================================================
FILE:    optimization.txt
VERSION: 1.3
DATE:    2021-03-11

----------------------------------------
See: optimization.txt
See: perl-setup.txt
See: perl-version_support.txt

----------------------------------------
Comments:

As pinxi/inxi gets larger and more feature complete, it's going to be important
to document true bottlenecks, so this is a tracking of that process.

Note that with a few exceptions, perl is using only the core modules as of
perl 5.08.

================================================================================

Sections:
1. SPEED TESTS
2. PERFORMANCE
3. TIMES PINXI/INXI
4. TIMES SC

================================================================================
SPEED TESTS
--------------------------------------------------------------------------------

The following have been tested with the following results:


========================================
ONE LINERS
----------------------------------------

========================================
AWK
----------------------------------------

NOTE: when using very small datasets, like --version output,
3 is faster than 2, but with larger data sets, exiting on find
make the large data set parse as fast as the smaller one

time:
1:
sub awk {
	my ($ref,$search,$num,$sep) = @_;
	my ($result);
	$num-- if $num > 0;
	$sep ||= '\s+';
	$result = (split /$sep/, (grep {/$search/} @$ref)[0])[$num];
	return $result;
}

loop 100:
small: 0.001658 0.001661 0.001158 0.001641
large: 0.031875 0.045241 0.039242s
2:
sub awk {
	eval $start if $b_log;
	my ($ref,$search,$num,$sep) = @_;
	my ($result);
	return if ! $ref;
	foreach (@$ref){
		if (/$search/){
			$result = $_;
			last;
		}
	}
	if ($result){
		$num-- if $num > 0; # retain the negative values as is
		$sep ||= '\s+';
		$result = (split /$sep/, $result)[$num];
	}
	
	eval $end if $b_log;
	return $result;
}
0.001567 0.001507 0.002727 0.003551 0.013866 0.012239

3: 
sub awk {
	eval $start if $b_log;
	my ($ref,$search,$num,$sep) = @_;
	my ($result);
	return if ! $ref;
	$result = (grep {/$sep/} @$ref)[0];
	if ($result){
		$num-- if $num > 0; # retain the negative values as is
		$sep ||= '\s+';
		$result = (split /$sep/, $result)[$num];
	}
	
	eval $end if $b_log;
	return $result;
}
small data: 0.00161 0.001516 0.001469
large data: 0.032708 0.040749 0.044881

4:
with cleaners added
sub awk {
	eval $start if $b_log;
	my ($ref,$search,$num,$sep) = @_;
	my ($result);
	return if ! @$ref;
	$sep ||= '\s+';
	foreach (@$ref){
		if (/$search/){
			$result = $_;
			$result =~ s/^\s+|\s+$//g;
			last;
		}
	}
	# $result = (grep {/$sep/} @$ref)[0];
	if ($result){
		$num-- if $num > 0; # retain the negative values as is
		$result = (split /$sep/, $result)[$num];
		$result =~ s/^\s+|\s+$//g if $result && $sep ne '\s+';
	}
	eval $end if $b_log;
	return $result;
}
large data: 0.00265 0.003334 0.002543 0.002976

5:
using while is the same speed
sub awk {
	eval $start if $b_log;
	my ($ref,$search,$num,$sep) = @_;
	my ($result);
	my $i = 0;
	return if ! @$ref;
	$sep ||= '\s+';
	while ($i <= scalar @$ref){
		# print "$$ref[$i]\n";
		if ($$ref[$i] =~ /$search/){
			$result = $$ref[$i];
			$result =~ s/^\s+|\s+$//g;
			last;
		}
		$i++;
	}
	# $result = (grep {/$sep/} @$ref)[0];
	if ($result){
		$num-- if $num > 0; # retain the negative values as is
		$result = (split /$sep/, $result)[$num];
		$result =~ s/^\s+|\s+$//g if $result && $sep ne '\s+';
	}
	eval $end if $b_log;
	return $result;
}
large data: 0.002565 0.003359 0.003411

----------------------------------------
different types of patterns

if (main::awk(\@xprop, '\"xfce4\"')){
10.2 ms!! yes, that much.

if (main::awk(\@xprop, 'xfce4')){
7.87ms

----------------------------------------
BASENAME/DIRNAME
----------------------------------------

use File::Basename;
my $file = '/proc-versions/text/some-thing.txt';
my $name = '';
$t0 = [gettimeofday];
foreach ( (0 .. 1000) ){
	# ($name) = $file =~ /([^\/]+)$/;
	$name = $file;
	#$name =~ s/^.*\///;
	#$name = basename($file);
	#$name = dirname($file);
	$name =~ s/[\/]+$//;
}
#my ($name) = $file =~ /([^\/]+)$/;
$t3 = tv_interval ($t0, [gettimeofday]);

This is to test if search from explicit end of string vs loose beginning is
faster. The results again are quite striking:

BASENAME
1: clean from start: 
   0.001824 - 0.00258 0.002241 0.002131
2: get part after last slash using assign to $1: 
   0.004883 - 0.005256
3. Use basename($file):
   0.027534 0.022597 0.027738
   
DIRNAME
1. use clean from end:
   0.004003 0.004572 0.004319 0.008257
2. Use dirname($file):
   0.018872 0.024931 0.019974 0.033945 0.022473 0.025499
   
----------------------------------------
POPULATE HASH MANUAL VS LOOP
----------------------------------------

## NOTE: running this 10k times resulted in a time difference
## of only about 50/1000ths of a second, which is nothing
## but in theory, I guess the manual method is slightly more efficient

print "start timer hash assign\n";
$t0 = [gettimeofday];

my %ids = (
'Array' => 1, # RAM or RAID
'Battery' => 1,
'Card' => 1,
'Device' => 1,
'Floppy' => 1,
'Hardware' => 1, # hardware raid report
'ID' => 1,
'IF-ID' => 1,
'Monitor' => 1,
'Optical' => 1,
'Screen' => 1,
'variant' => 1, # arm > 1 cpu type
);
foreach (0..10000){
	%ids = (
	'Array' => 1, # RAM or RAID
	'Battery' => 1,
	'Card' => 1,
	'Device' => 1,
	'Floppy' => 1,
	'Hardware' => 1, # hardware raid report
	'ID' => 1,
	'IF-ID' => 1,
	'Monitor' => 1,
	'Optical' => 1,
	'Screen' => 1,
	'variant' => 1, # arm > 1 cpu type
	);
}
$t3 = tv_interval ($t0, [gettimeofday]);
print "time manual: $t3\n";
$t0 = [gettimeofday];
foreach (0..10000){
	for (keys %ids){$ids{$_} = 1}
}
$t3 = tv_interval ($t0, [gettimeofday]);
print "time for: $t3\n";

time manual: 0.011499
time for: 0.01209

----------------------------------------
SEARCH - grep VS | string list VS hash key defined
----------------------------------------

sub get_shell_1 {
my ($test) = @_;
my $shells = 'ash|bash|csh|dash|elvish|es|eshell|fish|fizsh|';
$shells .= 'ion(sh)?|ksh|lksh|loksh|mksh||oh|oil|osh|';
$shells .= 'nash|pdksh|perl|posh|pysh(ell)?|rc|sh|su|sudo|';
$shells .= 'tcsh|xonsh|yash|zsh';
return ($test =~ /^($shells)$/) ? $test : '';
}

sub get_shell_2 {
my ($test) = @_;
my @shells = ('ash','bash','csh','dash','elvish','es','eshell','fish','fizsh',
'ion(sh)?','ksh','lksh','loksh','mksh','','oh','oil','osh',
'nash','pdksh','perl','posh','pysh(ell)?','rc','sh','su','sudo',
'tcsh','xonsh','yash','zsh');
return (grep {/^$test$/} @shells) ? $test : '';
}

sub get_shell_3 {
my ($test) = @_;
my %shells = ('ash' => '','bash' => '','csh' => '','dash' => '','elvish' => '','es' => '','eshell' => '','fish' => '','fizsh' => '',
'ion(sh)?' => '','ksh' => '','lksh' => '','loksh' => '','mksh' => '','' => '','oh' => '','oil' => '','osh' => '',
'nash' => '','pdksh' => '','perl' => '','posh' => '','pysh(ell)?' => '','rc' => '','sh' => '','su' => '','sudo' => '',
'tcsh' => '','xonsh' => '','yash' => '','zsh' => '',);
return (defined $shells{$test}) ? $test : '';
}

$t0 = [gettimeofday];
foreach (0..10000){
	my $shell = get_shell_1('zsh');
}
$t3 = tv_interval ($t0, [gettimeofday]);
print "regex with |: $t3\n";
$t0 = [gettimeofday];
foreach (0..10000){
	my $shell = get_shell_2('zsh');
}
$t3 = tv_interval ($t0, [gettimeofday]);
print "regex with grep: $t3\n";

$t0 = [gettimeofday];
foreach (0..10000){
	my $shell = get_shell_3('zsh');
}
$t3 = tv_interval ($t0, [gettimeofday]);
print "regex with hash key: $t3\n";

results:
regex with |: 0.008927
regex with grep: 0.118549
regex with hash key: 0.039852

regex with |: 0.009186
regex with grep: 0.121385
regex with hash key: 0.040259


----------------------------------------
Deferencing an array vs using it by reference
----------------------------------------

Tests showed that it's about 20% faster to not deference an array
but rather use it all by reference. 

One of many small improvements, if we keep chipping away 
at inxi performance we'll keep it reasonably quick as it gets bigger.

----------------------------------------
reference vs passing copy
----------------------------------------
sub cleaner {
	my ($item) = @_;
	return $item if !$item;# handle cases where it was 0 or ''
	# note: |nee trips engineering, but I don't know why nee was filtered
	$item =~ s/chipset|company|components|computing|computer|corporation|communications|electronics|electrical|electric|gmbh|group|incorporation|industrial|international|\bnee\b|revision|semiconductor|software|technologies|technology|ltd\.|<ltd>|\bltd\b|inc\.|<inc>|\binc\b|intl\.|co\.|<co>|corp\.|<corp>|\(tm\)|\(r\)|®|\(rev ..\)|\'|\"|\sinc\s*$|\?//gi;
	$item =~ s/,|\*/ /g;
	$item =~ s/\s\s+/ /g;
	$item =~ s/^\s+|\s+$//g;
	return $item;
}
sub cleaner_ref {
	return $_[0] if !$_[0];# handle cases where it was 0 or ''
	# note: |nee trips engineering, but I don't know why nee was filtered
	${$_[0]} =~ s/chipset|company|components|computing|computer|corporation|communications|electronics|electrical|electric|gmbh|group|incorporation|industrial|international|\bnee\b|revision|semiconductor|software|technologies|technology|ltd\.|<ltd>|\bltd\b|inc\.|<inc>|\binc\b|intl\.|co\.|<co>|corp\.|<corp>|\(tm\)|\(r\)|®|\(rev ..\)|\'|\"|\sinc\s*$|\?//gi;
	${$_[0]} =~ s/,|\*/ /g;
	${$_[0]} =~ s/\s\s+/ /g;
	${$_[0]} =~ s/^\s+|\s+$//g;
}
my $t0 = [gettimeofday()];
my $string = "apple corporation company is stupid <co> and will fail";
for (0 .. 300){
$string = cleaner($string);
#cleaner_ref(\$string);
}
$t3 = tv_interval($t0, [gettimeofday()]);
print " elapsed: $t3\n";
print "$string\n";
exit;

Results:
The two are essentially identical, no difference at all!

$string = cleaner($string):

elapsed: 0.005632
elapsed: 0.005768
elapsed: 0.005677

cleaner_ref(\$string):

elapsed: 0.005662
elapsed: 0.005594
elapsed: 0.006132

----------------------------------
Using Benchmark:

sub cleaner {
	my ($item) = @_;
	return $item if !$item;# handle cases where it was 0 or ''
	# note: |nee trips engineering, but I don't know why nee was filtered
	$item =~ s/chipset|company|components|computing|computer|corporation|communications|electronics|electrical|electric|gmbh|group|incorporation|industrial|international|\bnee\b|revision|semiconductor|software|technologies|technology|ltd\.|<ltd>|\bltd\b|inc\.|<inc>|\binc\b|intl\.|co\.|<co>|corp\.|<corp>|\(tm\)|\(r\)|®|\(rev ..\)|\'|\"|\sinc\s*$|\?//gi;
	$item =~ s/,|\*/ /g;
	$item =~ s/\s\s+/ /g;
	$item =~ s/^\s+|\s+$//g;
	return $item;
}

sub cleaner_ref {
	return $_[0] if !$_[0];# handle cases where it was 0 or ''
	# note: |nee trips engineering, but I don't know why nee was filtered
	${$_[0]} =~ s/chipset|company|components|computing|computer|corporation|communications|electronics|electrical|electric|gmbh|group|incorporation|industrial|international|\bnee\b|revision|semiconductor|software|technologies|technology|ltd\.|<ltd>|\bltd\b|inc\.|<inc>|\binc\b|intl\.|co\.|<co>|corp\.|<corp>|\(tm\)|\(r\)|®|\(rev ..\)|\'|\"|\sinc\s*$|\?//gi;
	${$_[0]} =~ s/,|\*/ /g;
	${$_[0]} =~ s/\s\s+/ /g;
	${$_[0]} =~ s/^\s+|\s+$//g;
}
my $string = "apple creates <co> with revision and many <ltd> items";
cmpthese(-4, {
'copy' => sub {
	$string = cleaner($string);
},
'ref' => sub {
	cleaner_ref(\$string);
},
});exit;

        Rate copy  ref
copy 42392/s   --  -1%
ref  42906/s   1%   --

------------------------------

my @a = (
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
'a','b','c','d','e','g','h',
);
cmpthese(-2, {
'a copy' => sub {
	my @b = a_copy(@a);
},
'a ref' => sub {
	my $b = a_ref(\@a);
},
});

sub a_copy {
my (@a) = @_;
return @a;
}
sub a_ref {
my ($a) = @_;
return $a;
}

            Rate a copy  a ref
a copy   42910/s     --   -99%
a ref  4937238/s 11406%     --



----------------------------------------
SUB vs METHOD :: Benchmark
----------------------------------------

https://perldoc.perl.org/Benchmark

https://www.perl.com/article/40/2013/9/29/How-to-benchmark-Perl-code-for-speed/

https://www.perlmonks.org/bare/?node_id=621709

use Benchmark qw(:all);

my $a = 10;
my $b = 20;

cmpthese(-2, {
        'Direct' => sub {
            my $c = $a+$b;
        },
        'Sub' => sub {
            my $c = add ($a, $b);
        },
        'Method' => sub {
            my $c = __PACKAGE__->meth_add ($a, $b);
        },
        'Method+sub' => sub {
            my $c = __PACKAGE__->meth_sub_add ($a, $b);
        },
        'Sub^2' => sub {
            my $c = add2 ($a, $b);
        },
        'Method^2' => sub {
            my $c = __PACKAGE__->meth2 ($a, $b);
        },
    });

sub add {
    return $_[0] + $_[1];
}

sub add2 {
    return add (@_);
}

sub meth_add {
    shift;
    return $_[0] + $_[1];
}

sub meth_sub_add {
    shift;
    return add (@_);
}

sub meth2 {
    return $_[0] -> meth_add ( $_[1], $_[2] );
}
[download]

And here are the results I get:

                Rate Method^2 Method+sub     Sub^2    Method       Sub    Direct
Method^2    500713/s       --       -22%      -37%      -44%      -58%      -91%
Method+sub  643967/s      29%         --      -19%      -27%      -46%      -88%
Sub^2       797484/s      59%        24%        --      -10%      -33%      -85%
Method      886331/s      77%        38%       11%        --      -26%      -84%
Sub        1191561/s     138%        85%       49%       34%        --      -78%
Direct     5397078/s     978%       738%      577%      509%      353%        --

--------

	timethis(-3, 
	sub {
		AudioData::get();
	}

	);

----------------------------------------
SWITCH
----------------------------------------

compared:

1:
my %assign = (
'B_ALLOW_UPDATE' => sub {$b_update = $val},
'B_ALLOW_WEATHER' => sub {$b_weather = $val},
'CPU_SLEEP' => sub {$cpu_sleep = $val},
....
if ($assign{$key}){
	$assign{$key}->();
}
foreach ((0..100)){ get_config_item('CONSOLE_COLOR_SCHEME',13)};

0.005842 0.006473 0.00669

2:

for ($key){
	if (/^B_ALLOW_UPDATE$/) {$b_update = $val}
	elsif (/^B_ALLOW_WEATHER$/) {$b_weather = $val}
	elsif (/^CPU_SLEEP$/) {$cpu_sleep = $val}
	
foreach ((0..100)){ get_config_item('CONSOLE_COLOR_SCHEME',13)};
0.00032 0.000269 0.000272

3:
if ($key eq 'B_ALLOW_UPDATE') {$b_update = $val}
elsif ($key eq 'B_ALLOW_WEATHER') {$b_weather = $val}
elsif ($key eq 'CPU_SLEEP') {$cpu_sleep = $val}
elsif ($key eq 'DL_TIMEOUT') {$dl_timeout = $val}

foreach ((0..100)){ get_config_item('CONSOLE_COLOR_SCHEME',13)};

0.000273 0.000242 0.000271 0.000238
   
========================================
TR vs s/.../../g; LENGTH
----------------------------------------

CLAIM: tr/!// # fastest way to count chars NOT TRUE!!

tr/a-z//d faster than s/[a-z]//g 
tr/q/Q/ faster than s/q/Q/g 

Data::Dumper::Indent = 0; 

my $file = 'well there are a whole lot of characters really there are!!! ';
foreach ( (0 .. 1000) ){
	#$name = length($file):
	$name = $file;
	$name =~ tr/!//;
}
$t3 = tv_interval ($t0, [gettimeofday]);
print "path: $name elapsed: $t3\n";

1. Using length():
   0.000193 0.000224 0.000172 0.000136
2. using tr 
   0.000837 0.000594 0.000603
   
-----------------------

my $name;
my $file = 'well there are a whole lot of characters really there are!!! ';
cmpthese(-1, {
'tr to count' => sub {
	$name = $file;
	$name =~ tr/!//;
},
'length to count' => sub {
	$name = length($file);
},
});
                       Rate     tr to count length to count
tr to count       8143526/s              --            -92%
length to count 102122184/s           1154%              --
   
----------------------------------------
USB
----------------------------------------

comparing:
1. set_usb_data_long 
2. set_usb_data_short

1.
0.123196 0.134307 0.117092 0.11261

2.
0.112249 0.117052 0.110115 0.16485 0.121433 0.115825 

pinxi -A
1.
0.446 0.431 0.440 0.455 0.397 0.385 0.453
2. 
0.373 0.408 0.385 0.403 0.410 0.402 0.426

1. lsusb >/dev/null 2>&1
2. lsusb -v >/dev/null 2>&1

1.
0.133 0.160 0.173 0.146 0.175 0.154

2.
0.163 0.171 0.156 0.161 0.176


   
========================================
PACKAGES / NAMESPACES
----------------------------------------

Packages: it makes basically zero difference re speed if you use:

$ob_my_package = MyPackage->new();
$result = MyPackage->runit();
or
$result = MyPackage::runit();
or
strip wrappers from MyPackage and convert it to a set of sub routines, not 
methods, and then:
$result = runit();

All timed on large loops of 100 to 500 at basically identical speeds. However, 
since I assume using new/bless to create a true new object rather than using 
static method calls will use more ram, for most package use the static method 
is used.
$result = MyPackage::runit();

----------------------------------------
using Benchmark:

                         Rate using package method     using sub direct
using package method 271773/s                   --                  -1%
using sub direct     273686/s                   1%                   --

One iteration came in at 2x faster for package, sub direct never really faster.


================================================================================
PERFORMANCE
--------------------------------------------------------------------------------

http://makepp.sourceforge.net/2.0/perl_performance.html

-----------------------------
https://stackoverflow.com/questions/19319989/my-perl-script-starts-too-slowly-and-includes-many-modules-can-i-precompile-i


If some of the packages you import are not needed at startup, change use calls 
to require and move them to the places in your code where the packages are needed 
(so you import them when they are needed, not necessarily at startup). Depending 
on how complex your program is, it could be a lot of work to figure out what calls 
can be changed without breaking your program or affecting its behavior.
----------------------------------------

Do NOT use this, ever. Trust optimizers over these random rules every time.

http://www.onlamp.com/2007/04/12/five-ways-to-improve-your-perl-programming.html

perlcritic -severity 5 program.pl

http://perlcritic.com
----------------------------------------
https://stackoverflow.com/questions/177122/how-can-i-speed-up-my-perl-program
So, assuming you actually have working code, run your program under Devel::NYTProf

https://metacpan.org/pod/Devel::NYTProf

https://metacpan.org/pod/Devel::DProf
----------------------------------------
use Benchmark ':all';
----------------------------------------
# get rid of the cpu sleep time
perl -d:NYTProf pinxi -Fa --sleep 0;nytprofhtml --open

nytprofhtml --open

perl -d:NYTProf pinxi -v8 --sleep 0;nytprofhtml --open

----------------------------------------
Devel::Cover
----------------------------------------

perl -MDevel::Cover /usr/local/bin/pinxi -Fa

Devel::Cover: getting BEGIN block coverage
Devel::Cover: 100% - 0s taken
Devel::Cover: getting CHECK block coverage
Devel::Cover: 100% - 0s taken
Devel::Cover: getting END/INIT block coverage
Devel::Cover: 100% - 0s taken
Devel::Cover: getting CV coverage
Devel::Cover: 100% - 10s taken
Devel::Cover: Writing coverage database to /home/harald/cover_db/runs/1672103920.1394668.09232
...

----------------- ------ ------ ------ ------ ------ ------
File                   stmt   bran   cond    sub   time  total
-------------------- ------ ------ ------ ------ ------ ------
/usr/local/bin/pinxi   32.5   19.9   15.6   41.1  100.0   25.0
Total                  32.5   19.9   15.6   41.1  100.0   25.0
-------------------- ------ ------ ------ ------ ------ ------

perl -MDevel::Cover /usr/local/bin/pinxi -v8
Devel::Cover 1.38: Collecting coverage data for branch, condition, statement, subroutine and time.
    Pod coverage is unavailable.  Please install Pod::Coverage from CPAN.
Selecting packages matching:
Ignoring packages matching:
    /Devel/Cover[./]
Ignoring packages in:
    /etc/perl
    /usr/lib/x86_64-linux-gnu/perl5/5.36
    /usr/share/perl5
    /usr/lib/x86_64-linux-gnu/perl-base
    /usr/lib/x86_64-linux-gnu/perl/5.36.0
    /usr/share/perl/5.36.0
System:
  Host: yawn Kernel: 5.19.0-16.2-liquorix-amd64 arch: x86_64 bits: 64
...

---  running-in: xfce4-terminal pinxi: 3.3.24-4
Devel::Cover: getting BEGIN block coverage
Devel::Cover: 100% - 0s taken
Devel::Cover: getting CHECK block coverage
Devel::Cover: 100% - 0s taken
Devel::Cover: getting END/INIT block coverage
Devel::Cover: 100% - 0s taken
Devel::Cover: getting CV coverage
Devel::Cover: 100% - 10s taken
Devel::Cover: Writing coverage database to /home/harald/cover_db/runs/1672104164.1394954.36638

-------------------- ------ ------ ------ ------ ------ ------
File                   stmt   bran   cond    sub   time  total
-------------------- ------ ------ ------ ------ ------ ------
/usr/local/bin/pinxi   36.8   22.2   17.3   45.2  100.0   28.2
Total                  36.8   22.2   17.3   45.2  100.0   28.2
-------------------- ------ ------ ------ ------ ------ ------



----------------------------------------
Devel::Profile
----------------------------------------

Devel::Size from #CPAN to discover #Perl variable memory usage 

https://metacpan.org/pod/Devel::MAT::Dumper
See also Devel::MAT: https://metacpan.org/dist/Devel-MAT/view/lib/Devel/MAT/UserGuide.pod

Installs a handler for the special __DIE__ signal to write a dump file when die() is about to cause a fatal signal. This is more reliable at catching the callstack and memory state than using an END block.

   $ perl -MDevel::MAT::Dumper=-dump_at_DIE ...
   
-dump_at_WARN

Installs a handler for the special __WARN__ signal to write a dump file when perl prints a warning.

   $ perl -MDevel::MAT::Dumper=-dump_at_WARN ...
   
 -dump_at_END

Installs an END block which writes a dump file at END time, just before the interpreter exits.

   $ perl -MDevel::MAT::Dumper=-dump_at_END ...  

   
Using this data:

https://tech.deriv.com/tracing-perl-memory-leaks-with-devel-mat-part-1/
https://tech.deriv.com/tracing-perl-memory-leaks-with-devel-mat-part-2/

----------------------------------------
speed up Perl:
http://www.perlworkshop.dk/2003/presentations/nwclark/slides.pdf

----------------------------------------

memory use:
https://perlmaven.com/how-much-memory-do-perl-variables-use

use strict;
use warnings;
use 5.010;

use Devel::Size qw(size total_size);

my $x;
my @y;
my %z;

say '                           size  total_size';
both('SCALAR', \$x);        #    24    24
both('ARRAY',  \@y);        #    64    64
both('HASH',   \%z);        #   120   120
both('CODE', sub {} );      #  8452  8452
say '';

both('SCALAR', \$x);        #  24    24
$x = 'x';
both('SCALAR-1', \$x);      #  56    56
$x = 'x' x 15;
both('SCALAR-15', \$x);     #  56    56
$x = 'x' x 16;
both('SCALAR-16', \$x);     #  72    72
$x = 'x' x 31;
both('SCALAR-31', \$x);     #  72    72
$x = 'x' x 32;
both('SCALAR-32', \$x);     #  88    88
$x = '';
both('SCALAR=""', \$x);     #  88    88
$x = undef;
both('SCALAR=undef', \$x);  #  88    88
undef $x;
both('undef SCALAR', \$x);  #  40    40
say '';

both('ARRAY',  \@y);               #    64    64
@y = ('x');
both('ARRAY-1', \@y);              #    96   152
@y = ('x' x 15);
both('ARRAY-15', \@y);             #    96   152
@y = ('x' x 16);
both('ARRAY-16', \@y);             #    96   168
@y = ('x' x 31);
both('ARRAY-31', \@y);             #    96   168
@y = ('x' x 32);
both('ARRAY-32', \@y);             #    96   184
@y = ('x') x 2;
both('ARRAY-1-1', \@y);            #    96   208
@y = ('x') x 4;
both('ARRAY-1-1-1-1', \@y);        #    96   320
@y = ('x') x 5;
both('ARRAY-1-1-1-1-1', \@y);      #   104   384
@y = ('x') x 6;
both('ARRAY-1-1-1-1-1-1', \@y);    #   112   448
@y = ('x') x 7;
both('ARRAY-1-1-1-1-1-1-1', \@y);  #   128   520
@y = ();
both('ARRAY = ()', \@y);           #   128   128
undef @y;
both('undef ARRAY', \@y);          #    64    64
say('');

both('HASH',   \%z);                       #  120   120
%z = ('x' => undef);
both('HASH x => undef',   \%z);            #  179   203
%z = ('x' => "x");
both('HASH x => "x"',   \%z);              #  179   235
%z = ('x' x 10 => "x" x 20);
both('HASH "x" x 10 => "x" x 20',   \%z);  #  188   260
for my $c (qw(a b c d e f g h i)) {
    $z{$c x 10} = $c x 20;
}
both('HASH 10 * 10 + 10 * 20',   \%z);     #  864  1584
%z = ();
both('HASH=()',   \%z);                    #  184   184
undef %z;
both('undef HASH',   \%z);                 #  120   120
my $o = bless \%z,'Some::Very::Long::Class::Name::That::Probably::Noone::Uses';
both('blessed HASH', $o);                  #  120   120
say('');

both('CODE', sub {}  );                   #  8516  8516
both('CODE2', sub { my $w }  );           #  8612  8612
both('CODE3', sub { my $w = 'a' }  );     #  8820  8820

sub both {
    my ($name, $ref) = @_;
    printf "%-25s %5d %5d\n", $name, size($ref), total_size($ref);
}

ram_use('HASH: alerts: ',\%alerts);ram_use('HASH: use: ',\%use);
ram_use('HASH: show: ',\%show);
ram_use('HASH: force:',\%force);ram_use('HASH: fake:',\%fake);
ram_use('ARRAY: @ps_cmd',\@ps_cmd);ram_use('ARRAY: @ps_aux',\@ps_aux);
ram_use('ARRAY: @devices_audio',\@devices_audio);
ram_use('HASH: %service_tool',\%service_tool);
ram_use('HASH: %client',\%client);
ram_use('PACKAGE: AudioData::get()',&AudioData::get());

----------------------------------------
Creat binary executables
----------------------------------------
https://www.marcbilodeau.com/compiling-perl/

That uses PAR to create an executable.

========================================
SYSTEMS USED
----------------------------------------

F8:  Perl 5.08 freebsd 7.3 32 bit
L10gw:  Perl 5.10 Debian 5.0 lenny, kernel 2.6.26 32 bit, mmx cpu, ssd
F12: Perl 5.12 freebsd 8.2 64 bit
L22: Perl 5.22 gnu/linux ubuntu kernel 4.4 64 bit, vm
L26y: Perl 5.26 gnu/linux debian kernel 4.9 32 bit
L26mm: Perl 5.26 gnu/linux debian stretch kernel 4.13, amd 2 core, ssd
L26my: Perl 5.26 gnu linux debian stretch kernel 4.13 intel core 2, ssd

========================================
REGEX
----------------------------------------

----------------------------------------
/.../o vs qr/.../ precompile regex
----------------------------------------

https://www.perlmonks.org/?node_id=269035

good discussion of how qr/ impacts stuff.

legacy /.../o to precompile, after Perl 5:

qr/.../

Note takeaway is perl alreayd checks against previous regex when using
scalar to hold regex pattern (try to use $pattern to hold these), and if the
same, does not recompile the regex, but if you use qr it doesn't have to do that
extra equality step.

https://perldoc.perl.org/perlop#Regexp-Quote-Like-Operators
Here are the quote-like operators that apply to pattern matching and related activities.

#
qr/STRING/msixpodualn 

The /a, /d, /l, and /u modifiers (added in Perl 5.14) control the character set 
rules, but /a is the only one you are likely to want to specify explicitly; the 
other three are selected automatically by various pragmas.

/i only added perl 5.14, don't use unless that's the earliest perl version 
supported.
 
========================================
SCALARS
----------------------------------------

All about scalars, hash, array, references:
https://gist.github.com/afair/2402068

========================================
HASH/ARRAY
----------------------------------------

use List::Util qw(first); 

I tested List::Util first vs grep to determine basically if is in array, in 
theory, first should have been hugely faster since it exits on first success, 
but in fact, using first instead of grep was 2 to 4x SLOWER:

2	17µs	2	9µs	push @phys_cpus, $line[1] if ! grep {/$line[1]/} @phys_cpus;
                  # spent     8µs making 1 call to CpuData::CORE:regcomp
                  # spent     1µs making 1 call to CpuData::CORE:match

                  
2	32µs	3	28µs	push @phys_cpus, $line[1] if ! List::Util::first {/$line[1]/} @phys_cpus;
                  # spent    20µs making 1 call to List::Util::first
                  # spent     7µs making 1 call to CpuData::CORE:regcomp
                  # spent     1µs making 1 call to CpuData::CORE:match

8099	45	348µs	90	324µs	                if ( $row{'dev-base'} !~ /^\/\/|:\// && ! (List::Util::first {/$row{'dev-base'}/} @devs) ){
                # spent   231µs making  9 calls to List::Util::first, avg 26µs/call
                # spent    69µs making 36 calls to DiskData::CORE:regcomp, avg 2µs/call
                # spent    24µs making 45 calls to DiskData::CORE:match, avg 529ns/call

45	143µs	81	49µs	                if ( $row{'dev-base'} !~ /^\/\/|:\// && ! (grep {/$row{'dev-base'}/} @devs) ){
                # spent    38µs making 36 calls to DiskData::CORE:regcomp, avg 1µs/call
                # spent    11µs making 45 calls to DiskData::CORE:match, avg 240ns/call
========================================
CLASSES
----------------------------------------

========================================
FUNCTIONS
----------------------------------------



========================================
STRICT
----------------------------------------

========================================
SECRET OPERATORS / CONSTANTS
----------------------------------------

Useful for speed, and one liners. 

Note that for is_numeric the more precise test, with more conditions in it,
is faster than the old sloppy /^[\d\.]+$/ test

Note that the length + tr/ tests are radically faster if null or empty

is_numeric: 10k iterations: 
1. 0.02 seconds
return 1 if ($_[0] =~ /^[0-9\.]+$/ && $_[0] =~ /\d/ && (() = $_[0] =~ /\./g ) <= 1);
2. 0.013 seconds
return 1 if ($_[0] =~ /^[0-9\.]+$/ && $_[0] =~ /\d/ && ($_[0] =~ tr/.// ) <= 1);
3. 0.011 seconds
return 1 if (length($_[0]) == (my $c = $_[0] =~ tr/0123456789.//) && $_[0] =~ /\d/ && ($_[0] =~ tr/.// ) <= 1);
4. 0.007-8 
return 1 if ( ( $_[0] =~ tr/0123456789//) >= 1 && length($_[0]) == ($_[0] =~ tr/0123456789.//) && ($_[0] =~ tr/.//) <= 1);
5. 0.007 to 0.009 
return 1 if ( defined $_[0] && length($_[0]) == ($_[0] =~ tr/0123456789.//) && ( $_[0] =~ tr/0123456789//) >= 1 && ($_[0] =~ tr/.//) <= 1);
# note: this is the old test, but it was also not correct since 9..8.9... or . or .0.0. would be true
7.  0.006 to 0.007
return 1 if (defined $_[0] && $_[0] =~ /^[\d\.]+$/);
8. 0.014 to 0.016
return 1 if $_[0] =~ /\d/ and $_[0] =~ /^[+-]?\d*\.\d*$/;


is_int: 10k iterations:
1. 0.007 to 0.008 seconds
return 1 if (defined $_[0] && $_[0] =~ /^[\d]+$/);
2. 0.005 to 0.006 seconds
return 1 if (defined $_[0] && length($_[0]) == ($_[0] =~ tr/0123456789//));
3. 0.0045 to 0.006 seconds
return 1 if (length($_[0]) && length($_[0]) == ($_[0] =~ tr/0123456789//));

further note: the my $c = is not necessary since the parentheses wrapping the expression achieves the same result

========================================
USE vs REQUIRE
----------------------------------------

========================================
WARNINGS
----------------------------------------

========================================

----------------------------------------


================================================================================
TIMES PINXI/INXI
--------------------------------------------------------------------------------

Tracking in documented form performance updates and tests.


I:  inxi for compare
 Ia: short form
 Ib: version
 Ic: -h help
P1: pre optimizations, uses -> on packages, non optimized utilities. patch 64
 P1a: short form
 P1b: version
 P1c: help -h
 P1d: --alt 3 test printer
P2: post optimizations 1.
 P2a: short form
 P2b: version
 P3b: --alt 3 test printer

P1 is pinxi patch 65 at the basic 4000 line stage, before most real data features are 
used.

I is inxi at about 16000 lines, full logic, bash/gawk

========================================
Ia
----------------------------------------
F8:
real	0m0.472s
user	0m0.110s
sys	0m0.141s

real	0m0.231s
user	0m0.142s
sys	0m0.100s

real	0m0.269s
user	0m0.151s
sys	0m0.099s

----------------------------------------
F12:
0.073u 0.076s 0:02.34 5.9%	828+5334k 0+16io 14pf+0w
0.095u 0.040s 0:00.20 65.0%	998+5913k 0+16io 0pf+0w
0.065u 0.058s 0:00.13 84.6%	1010+6331k 0+16io 0pf+0w
0.079u 0.047s 0:00.13 84.6%	943+5743k 0+16io 0pf+0w

real 1.66
user 0.07
sys 0.03

real 0.13
user 0.08
sys 0.04

----------------------------------------
L10gw:
4.101
4.008
4.063

----------------------------------------
L22:
real	0m0.259s
user	0m0.184s
sys	0m0.056s

real	0m0.240s
user	0m0.164s
sys	0m0.056s

real	0m0.276s
user	0m0.204s
sys	0m0.052s

----------------------------------------
L26mm:
0.63
0.625
0.681

----------------------------------------
L26my:
0.664
0.475
0.477 
0.463

----------------------------------------
L26y:
real	0m0.234s
user	0m0.198s
sys	0m0.042s

real	0m0.256s
user	0m0.205s
sys	0m0.047s

========================================
Ib
----------------------------------------
F8:
real	0m0.313s
user	0m0.158s
sys	0m0.047s

real	0m0.199s
user	0m0.116s
sys	0m0.086s

real	0m0.195s
user	0m0.116s
sys	0m0.085s
----------------------------------------
F12:
0.078u 0.034s 0:00.55 18.1%	774+4451k 0+0io 1pf+0w
0.071u 0.044s 0:00.12 91.6%	842+4379k 0+0io 0pf+0w
0.077u 0.031s 0:00.10 100.0%	852+4925k 0+0io 0pf+0w

----------------------------------------
L10gw:
3.408
3.414
3.447

----------------------------------------
L22:
real	0m0.594s
user	0m0.160s
sys	0m0.052s

real	0m0.582s
user	0m0.140s
sys	0m0.088s


----------------------------------------
L26mm:
0.260
0.262
0.254

----------------------------------------
L26my:
0.112
0.101
0.109

----------------------------------------
L26y:
real	0m0.694s
user	0m0.311s
sys	0m0.084s

real	0m0.713s
user	0m0.318s
sys	0m0.097s

========================================
1c
----------------------------------------

----------------------------------------
F8:
real	0m1.509s
user	0m0.451s
sys	0m1.115s

real	0m1.641s
user	0m0.335s
sys	0m1.261s

----------------------------------------
F12:
0.214u 0.601s 0:06.46 12.5%	836+7128k 0+660io 1pf+0w
0.227u 0.629s 0:05.12 16.4%	849+7284k 0+660io 0pf+0w
0.294u 0.565s 0:03.48 24.4%	688+5850k 0+660io 0pf+0w

----------------------------------------
L10gw:
15.027
14.949
15.014

----------------------------------------
L22:
real	0m1.960s
user	0m0.296s
sys	0m0.396s

real	0m2.038s
user	0m0.296s
sys	0m0.420s

real	0m2.018s
user	0m0.292s
sys	0m0.432s


----------------------------------------
L26mm:
1.825
1.826
1.855

----------------------------------------
L26my:
0.630
0.640
0.640

----------------------------------------
L26y:
real	0m1.420s
user	0m0.723s
sys	0m0.418s

real	0m1.475s
user	0m0.743s
sys	0m0.402s

========================================
P1a
----------------------------------------
F8:
real	0m0.288s
user	0m0.117s
sys	0m0.062s

real	0m0.177s
user	0m0.122s
sys	0m0.053s

real	0m0.173s
user	0m0.129s
sys	0m0.046s

real	0m0.193s
user	0m0.122s
sys	0m0.054s

----------------------------------------
F12:
0.202u 0.066s 0:01.55 16.7%	19+1572k 0+0io 1pf+0w
0.120u 0.060s 0:00.34 52.9%	22+1542k 0+0io 0pf+0w
0.181u 0.032s 0:00.34 61.7%	4+1470k 0+0io 0pf+0w
0.143u 0.041s 0:00.34 52.9%	6+1376k 0+0io 0pf+0w
0.140u 0.055s 0:00.34 55.8%	18+1532k 0+0io 0pf+0w

real 0.31
user 0.13
sys 0.04

real 0.31
user 0.11
sys 0.07

----------------------------------------
L10gw:
4.52
4.443
4.436

----------------------------------------
L22: 
real	0m0.317s
user	0m0.196s
sys	0m0.080s

real	0m0.284s
user	0m0.204s
sys	0m0.052s

----------------------------------------
L26mm:
0.454
0.357
0.344

----------------------------------------
L26my:
0.415
0.194
0.195

----------------------------------------
L26y:
real	0m0.310s
user	0m0.269s
sys	0m0.071s

real	0m0.403s
user	0m0.348s
sys	0m0.082s

real	0m0.378s
user	0m0.331s
sys	0m0.074s

========================================
P1b
----------------------------------------
F8:
real	0m0.205s
user	0m0.121s
sys	0m0.064s

real	0m0.160s
user	0m0.094s
sys	0m0.067s

real	0m0.180s
user	0m0.125s
sys	0m0.036s

----------------------------------------
F12:
0.155u 0.002s 0:00.15 100.0%	33+1452k 0+0io 0pf+0w
# pause
0.188u 0.070s 0:00.55 45.4%	9+1547k 0+0io 0pf+0w
0.127u 0.042s 0:00.22 72.7%	25+1822k 0+0io 0pf+0w
0.133u 0.029s 0:00.25 60.0%	5+1726k 0+0io 0pf+0w
0.110u 0.047s 0:00.24 62.5%	7+1614k 0+0io 0pf+0w

----------------------------------------
L10gw:
4.301
4.326
4.357

----------------------------------------
L22:
real	0m0.259s
user	0m0.184s
sys	0m0.056s

real	0m0.240s
user	0m0.164s
sys	0m0.056s

real	0m0.276s
user	0m0.204s
sys	0m0.052s

----------------------------------------
L26mm:
0.316
0.349
0.323

----------------------------------------
L26my:
0.163
0.166
0.337
0.160

----------------------------------------
L26y:
real	0m0.332s
user	0m0.288s
sys	0m0.050s

real	0m0.370s
user	0m0.327s
sys	0m0.042s

========================================
P1c
----------------------------------------

----------------------------------------
F8:
real	0m0.194s
user	0m0.115s
sys	0m0.054s

real	0m0.512s
user	0m0.105s
sys	0m0.072s

real	0m0.167s
user	0m0.129s
sys	0m0.038s

real	0m0.209s
user	0m0.113s
sys	0m0.071s

----------------------------------------
F12:
0.141u 0.016s 0:00.69 21.7%	5+1556k 0+0io 0pf+0w
0.134u 0.023s 0:00.31 48.3%	13+1549k 0+0io 0pf+0w
0.148u 0.022s 0:00.75 21.3%	13+1747k 0+0io 0pf+0w

----------------------------------------
L10gw:
4.898 
4.843
4.820

----------------------------------------
L22:
real	0m0.243s
user	0m0.156s
sys	0m0.068s

real	0m0.238s
user	0m0.180s
sys	0m0.040s

----------------------------------------
L26mm:
0.344 
0.320
0.315

----------------------------------------
L26my:
0.167 
0.361
0.352
0.167 
0.158 
0.155

----------------------------------------
L26y:
real	0m0.377s
user	0m0.333s
sys	0m0.041s

real	0m0.357s
user	0m0.296s
sys	0m0.055s

real	0m0.340s
user	0m0.293s
sys	0m0.044s

========================================
P1d
----------------------------------------

----------------------------------------
F8:
real	0m0.172s
user	0m0.143s
sys	0m0.033s

real	0m0.238s
user	0m0.120s
sys	0m0.057s

real	0m0.170s
user	0m0.132s
sys	0m0.041s

----------------------------------------
F12:
0.127u 0.033s 0:00.25 60.0%	5+1718k 0+0io 0pf+0w
0.140u 0.025s 0:00.34 47.0%	5+1682k 0+0io 0pf+0w
0.133u 0.027s 0:00.34 44.1%	6+1546k 0+0io 0pf+0w

----------------------------------------
L10gw:
4.546 
4.510
4.503

----------------------------------------
L22:
real	0m0.291s
user	0m0.192s
sys	0m0.068s

real	0m0.297s
user	0m0.200s
sys	0m0.076s

----------------------------------------
L26mm:
0.358 
0.385
0.345

----------------------------------------
L26my:
0.176 
0.193 
0.176

----------------------------------------
L26y:
real	0m0.387s
user	0m0.329s
sys	0m0.078s

real	0m0.399s
user	0m0.324s
sys	0m0.073s

========================================

----------------------------------------

----------------------------------------
F8:

----------------------------------------
F12:

----------------------------------------
L10gw:


----------------------------------------
L22:

----------------------------------------
L26mm:

----------------------------------------
L26my:

----------------------------------------
L26y:


================================================================================
START CLIENT
--------------------------------------------------------------------------------
 
SC1: start_client.pl pre optimizations
SC2: start_client.pl post
SC3: removed package wrapper

========================================
SC1
----------------------------------------

time for (( i=0;i<100;i++));do ./start_client.pl 'ob';done

time for (( i=0;i<500;i++));do ./start_client.pl 'ob';done

----------------------------------------
F8:

----------------------------------------
F12:

----------------------------------------
L10gw:


----------------------------------------
L22:
real	0m3.706s
user	0m1.408s
sys	0m1.400s

----------------------------------------

real	0m18.838s
user	0m7.376s
sys	0m6.888s


----------------------------------------
L26mm:

----------------------------------------
L26my:

----------------------------------------
L26y:
real    0m0.075s
user    0m0.043s
sys     0m0.038s

real    0m0.083s
user    0m0.043s
sys     0m0.043s

real    0m0.083s
user    0m0.043s
sys     0m0.043s

real    0m0.052s
user    0m0.028s
sys     0m0.024s

real    0m0.072s
user    0m0.043s
sys     0m0.034s

----------------------------------------

real    0m3.804s
user    0m2.340s
sys     0m1.618s

real    0m3.765s
user    0m2.264s
sys     0m1.619s

real    0m4.030s
user    0m2.495s
sys     0m1.770s

----------------------------------------

real    0m19.435s
user    0m11.781s
sys     0m8.628s

real    0m19.481s
user    0m11.766s
sys     0m8.732s

========================================
SC2
----------------------------------------

time for (( i=0;i<100;i++));do ./start_client.pl 'st';done


time for (( i=0;i<500;i++));do ./start_client.pl 'st';done

----------------------------------------
F8:

----------------------------------------
F12:

----------------------------------------
L10gw:


----------------------------------------
L22:
real	0m3.721s
user	0m1.452s
sys	0m1.344s

----------------------------------------

real	0m18.361s
user	0m7.216s
sys	0m6.552s

----------------------------------------
L26mm:

----------------------------------------
L26my:

----------------------------------------
L26y:

real    0m4.045s
user    0m2.423s
sys     0m1.780s

real    0m3.899s
user    0m2.337s
sys     0m1.717s

real    0m3.862s
user    0m2.301s
sys     0m1.772s

----------------------------------------

real    0m19.433s
user    0m11.927s
sys     0m8.795s

real    0m19.707s
user    0m11.973s
sys     0m8.790s

========================================
SC3
----------------------------------------

time for (( i=0;i<100;i++));do ./start_client.pl 'nc';done


time for (( i=0;i<500;i++));do ./start_client.pl 'nc';done

----------------------------------------
F8:

----------------------------------------
F12:

----------------------------------------
L10gw:


----------------------------------------
L22:
real	0m3.802s
user	0m1.532s
sys	0m1.348s

----------------------------------------

real	0m19.267s
user	0m7.380s
sys	0m7.204s

----------------------------------------
L26mm:

----------------------------------------
L26my:

----------------------------------------
L26y:

real    0m4.259s
user    0m2.482s
sys     0m1.828s

real    0m4.002s
user    0m2.394s
sys     0m1.844s

real    0m4.029s
user    0m2.388s
sys     0m1.855s

----------------------------------------

real    0m19.539s
user    0m11.759s
sys     0m8.898s

real    0m19.621s
user    0m11.836s
sys     0m9.030s

